1) BINARY SEARCH
; Load key to be searched
LDA 204FH          ; Load key into accumulator A
MOV B, A           ; Store key into register B

; Initialize
XRA A              ; Clear accumulator
STA 2065H             ; Store 00H at 2065H  (iteration counter)
MOV L, A           ; Set L = 00H (lower limit)
MVI H, 09H         ; H = 09H (upper limit, assuming 10 elements)

; Start of binary search
START:
LDA 2065H         ; Load number of iterations into A
INR A              ; Increment iteration counter
STA 2065H            ; Store back to 2065H

;while(low<=high) or else terminate loop
MOV A, H           ; Move upper limit to A
CMP L              ; Compare upper limit (H) with lower limit (L)
JC  L2             ; If H < L (carry set), jump to L2 (not found)

; Calculate Mid
;(mid = (low+high)/2))
ADD L              ; A = H + L
RAR                ; A = (H + L) / 2 -> effectively right rotation divides by 2
MOV C, A           ; Store Mid into register C(=mid)

; Find address of Mid element(arr[mid])
LXI D, 2050H       ; DE points to start of array (F110H)
ADD E              ; A = A + E (offset by mid) (suppose DE->2050 => D=20, E=50. Now, A(that has current mid) = 4. A = A+E -> A = 4+50 = 54.
MOV E, A           ; Update E with A  -> NOW E = 54H -> DE = 2054H
XRA A              ; Clear accumulator (A=0)
ADC D              ; Add D and carry (A = A + D + Carry)(consider a situation where DE = 20FEH, now A=A+E = FE+04=102H->not fitting in 8 bit -> carry generated by A=A+E addition is transferred to D)
MOV D, A           ; Update D -> Final ADDRESS of mid found at DE

; Compare Mid element with key(arr[mid] == key)(Condition 1)
LDAX D             ; Load value at address DE into A
CMP B              ; Compare A with key (B)
JC ELSE            ; If mid-element(A) < key(B), jump to ELSE(carry is set)
JZ PRINT           ; If mid-element(A) == key(B), jump to PRINT

; If mid-element > key
MOV A, C           ; Load Mid(C) into A
DCR A              ; Mid = Mid - 1
MOV H, A           ; Update upper limit H(high = mid+1)
JMP START          ; Jump to START(jump to new iteration)

; Mid-element(A) < key(B)  -> (arr[mid] < key) -> (low = mid+1)
ELSE:
MOV A, C           ; Load Mid(C) into A
INR A              ; Mid = Mid + 1
MOV L, A           ; Update lower limit L(low = mid+1)
JMP START          ; Jump to START(jump to new iteration)

; Key found
PRINT:
MVI A, 01H         ; Load A with 01H (key found)
STA 2060H          ; Store result (found) at 2060H 
MOV A, C           ; Move Mid (index in C) into A
STA 2061H          ; Store index at 2061H
JMP END            ; Jump to END

; Key not found
L2:
MVI A, 02H         ; Load A with 02H (key not found)
STA 2060H          ; Store result (not found) at 2060H 

; End of Program
END:
HLT                ; Halt


2) BUBBLE SORT
START:  
LXI H, 204FH      ; Number of elements of array stored in C (IN-BUFFER at 204FH)

MVI D, 00H        ; D register is used as a flag register (no exchanges yet)
MOV C, M          
DCR C             ; Decrement count (C = number of comparisons needed) as we are doing "INX H" -> pointing to first data so now 9 comparisons needed for 10 elements
INX H        ; Point to first actual data (after count)

LOOP:
MOV A, M          ; Load current element into A(arr[i])
INX H             ; Move to next element(arr[i+1])
CMP M             ; Compare A with next element
JC NEXTBYT        ; If A(arr[i]) < M(arr[i+1]), no exchange needed â†’ jump to NEXTBYT(no swap -> valid order found)

; Exchange process(swap needed as A(arr[i]) >= M(arr[i+1]))
MOV B, M          ; Move second element into B (B = arr[i+1])
MOV M, A          ; Move first element into second location(M is pointing to 2nd location where first element arr[i] gets inserted)
DCX H             ; Go back to first location(M now points to the 1st location)
MOV M, B          ; Move second element into first location(M(that points t the 1st location) now gets assigned to arr[i+1](B)) (swap successful)
INX H             ; Move forward again(for further iterations, start memory pointer from next location)
MVI D, 01H        ; Set flag D = 1 indicating an exchange occurred(it is a swap flag -> corresponding to the "swapped" variable of the modified bubble sort algorithm -> D=1 means swapped = true)

NEXTBYT:
DCR C             ; Decrement comparison counter
JNZ LOOP         ; If not 0, continue comparing

MOV A, D          ; Move flag into accumulator(it is done to check if the rightmost bit is set -> operation easily applicable on A)
RRC               ; Rotate flag bit into Carry(Send the rightmost bit LSB to carry)
JC START          ; If carry is set (flag=1), another pass needed(in this case, if carry is set -> that means D was 1 in the inner "LOOP" -> that means in the course
; of current iteration in bubble sort, there was atleast 1 swap to reorder the elements. Tallying with the modified bubble sort algorithm which terminated the outer
; loop when swapped = false(if(swapped ==  false) break) -> in this case, if there was NO SWAP during current iteration of bubble sort, D remains 00H which means carry = 0
; which means JC START terminates. If there is ATLEAST ONE SWAP in current iteration of bubble sort, D becomes 01H which means carry is set -> JC CARRY is valid -> OUTER LOOP starts again -> another swap starts

HLT               ; Otherwise, halt (array sorted)
